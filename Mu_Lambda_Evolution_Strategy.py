# Implementation of (MU, LAMBDA) Evolution Strategy
import random
import math

X_MIN = -0.20 # minimum x allowed
X_MAX = 1.120 # maximum x allowed
MU = 5 # number of parents selected
LAMBDA = 20 # number of children generated by the parents
P_CROSSOVER = 0.3 # probability of crossover
CHROMOSOME_SIZE = 4 # define the length of binary string

# function f(x) ****TEST FUNCTION HERE****
def f(chromosome):
    x = inContext(X_MIN, X_MAX, toDecimal(chromosome), CHROMOSOME_SIZE)
    return (6*x-2)**2 * math.sin(12*x-4)

# generate initial population
def initial_population(n_population):
    population = []
    for p_index in range(n_population):
        chromosome = ""
        for c_index in range(CHROMOSOME_SIZE):
            chromosome += random.choice(["0", "1"])
        population.append(chromosome)
    return population

# loop stops when the condition is not met
def loop_condition_is_met(bestGene, timeCounter):
    timeLimit = 10
    idealSolution = 15.91
    precision = 0.001
    return abs(idealSolution - f(bestGene, CHROMOSOME_SIZE)) > precision and\
            timeCounter < timeLimit

# convert the binary into decimal
def toDecimal(binaryString):
    decimalNumber = 0
    length = len(binaryString)
    for index, digit in enumerate(binaryString):
        if digit == "1":
            decimalNumber += 2**(length - index - 1)
    return decimalNumber

# convert the decimal number into real value in context
def inContext(x_min, x_max, decimal):
    r_min = 0.0
    r_max = 2**CHROMOSOME_SIZE-1
    precision = (x_max - x_min) / (r_max - r_min)
    return x_min + decimal * precision

# return top {MU} individuals
def truncation_selection(fitnessList, mu):
    indices = []
    # copy of the fitness list
    tempList = fitnessList
    for counter in range(mu):
        bestIndex = 0 # initially set the best as 0
        bestFitness = tempList[0] # initially set the best as index 0
        for index, fitness in enumerate(tempList):
            if tempList[index] > bestFitness:
                bestIndex = index
        indices.append(bestIndex) # add the best index to indices
        tempList.remove(bestIndex) # remove the best from the list
    # return the indices of the top scored individuals
    return indices

# take two chromosomes and return their children via uniform crossover
def uniform_crossover(adam, eve):
    for index in range(CHROMOSOME_SIZE):
        if random.uniform(0.0, 1.0) < P_CROSSOVER:
            temp = adam[index]
            adam[index] = eve[index]
            eve[index] = temp
    return adam, eve

# (MU, LAMBDA) Evolution Strategy main function
def mu_lambda_evoulution_strategy():
    population = initial_population(LAMBDA)
    bestGene = "XXXX" # initially best is nobody
    timeCounter = 0
    while loop_condition_is_met(bestGene, timeCounter):
        # list that stores fitness of chromosomes with the same indices
        fitness = []
        for chromosome in population:
            # assess fitness
            fitness.append(f(chromosome))
            # determine the best gene
            if bestGene == "XXXX" or\
             f(chromosome) > f(bestGene):
                bestGene = chromosome
        # the MU individuals in P whose fitness are greatest
        survivors = []
        for index in truncation_selection(fitness, MU):
            survivors.append(fitness[index])





        timeCounter += 1







# execute
mu_lambda_evoulution_strategy()
